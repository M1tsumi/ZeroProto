use zeroproto::*;

# [derive (Debug , Clone , Copy , PartialEq , Eq)] pub enum UserStatus { Active = 1 , Inactive = 2 , Pending = 3 } impl UserStatus { # [doc = r" Read this enum from a buffer"] pub fn read (buf : & [u8] , offset : usize) -> zeroproto :: Result < Self > { let value = Endian :: Little . read_u64 (buf , offset) ; match value { 1 => Ok (UserStatus :: Active) , 2 => Ok (UserStatus :: Inactive) , 3 => Ok (UserStatus :: Pending) , _ => Err (zeroproto :: Error :: InvalidFieldType) , } } # [doc = r" Write this enum to a buffer"] pub fn write (& self , buf : & mut [u8] , offset : usize) -> zeroproto :: Result < () > { let value = match self { UserStatus :: Active => 1 , UserStatus :: Inactive => 2 , UserStatus :: Pending => 3 , } ; Endian :: Little . write_u64 (value , buf , offset) ; Ok (()) } }

pub const FIELD_0_OFFSET: usize = 27;
pub const FIELD_1_OFFSET: usize = 35;
pub const FIELD_2_OFFSET: usize = 39;
pub const FIELD_3_OFFSET: usize = 43;
pub const FIELD_4_OFFSET: usize = 47;


# [doc = r" Zero-copy reader for #reader_name messages"] # [derive (Debug)] pub struct UserReader < 'a > { reader : MessageReader < 'a > , } impl < 'a > UserReader < 'a > { # [doc = r" Create a new reader from a message reader"] pub fn new (reader : MessageReader < 'a >) -> Self { Self { reader } } # [doc = r" Create a new reader from raw bytes"] pub fn from_bytes (data : & 'a [u8]) -> zeroproto :: Result < Self > { Ok (Self :: new (MessageReader :: new (data) ?)) } } impl < 'a > UserReader < 'a > { # [doc = r" Create a reader from a byte slice"] pub fn from_slice (data : & 'a [u8]) -> zeroproto :: Result < Self > { Self :: from_bytes (data) } } impl < 'a > UserReader < 'a > { # [doc = r" Get the #method_name field"] pub fn user_id (& self) -> zeroproto :: Result < u64 > { self . reader . get_scalar (0u16) } # [doc = r" Get the #method_name field"] pub fn name (& self) -> zeroproto :: Result < & 'a str > { self . reader . get_scalar (1u16) } # [doc = r" Get the #method_name field"] pub fn age (& self) -> zeroproto :: Result < u32 > { self . reader . get_scalar (2u16) } # [doc = r" Get the #method_name field"] pub fn status (& self) -> zeroproto :: Result < UserStatus > { self . reader . get_scalar (3u16) } # [doc = r" Get the #method_name field"] pub fn tags (& self) -> zeroproto :: Result < VectorReader < 'a , & 'a str > > { self . reader . get_vector (4u16) } }

# [doc = r" Builder for #builder_name messages"] # [derive (Debug)] pub struct UserBuilder { builder : MessageBuilder , } impl UserBuilder { # [doc = r" Create a new builder"] pub fn new () -> Self { Self { builder : MessageBuilder :: new () , } } } impl UserBuilder { # [doc = r" Set the #method_name field"] pub fn set_user_id (& mut self , value : u64) -> & mut Self { self . builder . set_scalar (0u16 , value) . unwrap () ; self } # [doc = r" Set the #method_name field"] pub fn set_name (& mut self , value : & 'a str) -> & mut Self { self . builder . set_scalar (1u16 , value) . unwrap () ; self } # [doc = r" Set the #method_name field"] pub fn set_age (& mut self , value : u32) -> & mut Self { self . builder . set_scalar (2u16 , value) . unwrap () ; self } # [doc = r" Set the #method_name field"] pub fn set_status (& mut self , value : UserStatus) -> & mut Self { self . builder . set_scalar (3u16 , value) . unwrap () ; self } # [doc = r" Set the #method_name field"] pub fn set_tags (& mut self , values : & [& 'a str]) -> & mut Self { self . builder . set_vector (4u16 , values) . unwrap () ; self } # [doc = r" Finish building and return the serialized message"] pub fn finish (self) -> Vec < u8 > { self . builder . finish () } # [doc = r" Finish building and return a reader"] pub fn finish_reader (self) -> zeroproto :: Result < UserReader < 'static >> { let bytes = self . finish () ; UserReader :: from_bytes (& bytes) } } impl Default for UserBuilder { fn default () -> Self { Self :: new () } }

